ცალკეულ templates ფოლდერს ვქმნით იმისათვის რომ ამ ფოლერში შევინახოთ ისეთი კოდი, რომელსაც ხშირად ვიყენებთ
მაგ: htmlის navbarს რომელიც მუდად სტატიკური ხდება ყველა გვერდისათვის, იმისათვის რომ navbarყველა გვერდისათვის ცალკე არ გავუწეროთ
უმჯობესია შევქმნათ ცაკლეული html ფაილი და შემდგომ ეს ფაილი გამოვიყენოთ სხვა გვერდებისათვისაც და ნავბარი ამ ფილიდან ჩავაიმპლენტოთ(ძირითადად base.htmlს ვარქმევთ ამ გვერდს)
ხოლო ისეთ რაღაცას რაც განსხვავეული უნდა იყო სხვა გვერდებისათვის, უნდა შეიქმნას კონკრეტულ html დოკუმენტაციაში
ხოლო ისეთი დოკუმენტაცია რაც უნდა იყოს განსხვავებული უნდა ჩავწეროთ წინასწარ შემქნილ ბლოკებში - კონტენტ ბლოკში, რომელსაც ვქმნით jinja2 ის ენით
{% block content %}
{% endblock %}

ხოლო საერთო html ფაილის სხვა ფაილებში გამოსაჩენად ისევ jinja2ს ვიყენებთ, თუკი html დოკუმენტის იმპლემენტაციას ვაკეთებთ, html დოკუმენტაციის ჩაწერა აღარაა საჭირო,
არამედ პირდაპირ ვაიმპლენტებთ html დოკუმენტს, {% extends base.html %} extends ბლოკი არ იხურება

titleს გასაწერად jinja2ის ენით ვუწერთ {% block title %} title name {% endblock %}

    <!doctype html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
              content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>{% block title %} აქ კი იწერება title, ყოველი გგვერდისათვის არის განსხვავებული{%endblock%}</title>
    </head>
    <body>
        <div class="container" ...>
        </div>
        {% block content %}
        აქ იწერება ის დოკუმენტაცია რომელიც არის განსხვავებული სხვა გვერებისათვის
        {% endblock %}
    </body>
    </html>



ასეთ html ფაილებს კი ვანახავთ მთავარ templates ფოლდერში, რომელიც შემდგომ settings.pyდან უნდა გავუწეროთ რომ მიაკითხოს მთავარ templatesს გვერდში და აქედან წაიღოს დოკუმენტაცია
ამისათვის settings.py ში უნდა შევიდეთ templates ლისტში DIRS უნდა გავუწეროთ რომ მიაკითხოს [BASE_DIR / 'templates'], ჯერ მიაკითხოს BASE_DIRs,
მთავარ საქაღალდეს, ხოლო თუ აქ არ დახვდა მაშინ მონახოს აპლიკაციის templatesებშიm





###################################################################
მეორე მეთოდია რომ საერთო html დოკუმენტებიც დავყოთ და ისე შემოვიტანოთ base.htmlიდან
მაგ: navbar ცალკე შევქმნათ, footerიც ცალკე შევქმნათ,
ამ ფაილებს კი ძირითადად ვინახავთ partials საქაღალდეში, რომელიც კი ინახება მთავარ templates საქაღალდეში

მაგრამ ამისათვის, base.htmlდან უნდა წამოვიღოთ სხვა html დოკუმენტებში, ჯერ base.htmlმა უნდა წაიკითხოს ეს დოკუმენტაცია,
ამიტომ partials საქაღალდეში შექმნილი დოკუმენტაცია უნდა დავაინქლუდოთ base.htmlში, რისთვისაც ისევ jinjaს ენას ვიყენებთ{% include 'partials/documentation.html' %}
მისამართიც ისე უნდა გავუწეროთ რომელ ფაილშიც ვინახავთ








######################################################################################################################################
debugger tool - გვეხმარება მოთხოვნების შესამცირებლად / ბაზაზე მოთხოვნები რომ არ წავიდეს და არ გადაიტვირთოს / პლიუს დუბლირებული ქვერები რომ არ წამოვიდეს
ამაში დაგვეხმარება debiggertoolbar, ამისათვის ჯერ უნდა დავაინსტალროთ - pip install django-debug-toolbar, dდაინსტალირების შემდეგ კი უნდა დავამატოთ requirments.txtში
როცა დავაიმპორტებთ, settings.py ში და მტავარი პროექტის urls.py შიც უნდა დავაიმპორტოთ და შემოვიტანოთ debig-toolbar
დაიმპორტების დროს, დოკუმენტაციაშივე აგვიხსნის სად უნდა შემოვიტანოთ toolbar

debug_toolbar გვიჩვენებს მოთხოვების რაოდენობას ჩვენს გვერდებზე, თუკი მონაცემის წამოღება / გაშვების და ატვირთვის დროს რამდენი მოთხოვნა მოდის სისტემაზე,
რათა შევძლოთ ამ მოთხოვნების გაფილტვრა, იმისათვის რომ სისტემამ უფრო ეფექტურად იმუშაოს და დუბლურებული მოთხოვნები ავირიდოთ თავიდან

როდესაც ვიუებს ვქმნით, ბაზიდან ამოიღოს მონაცემები, მოდის ერთი მოთხოვნა, მაგრამ თუკი მონაცემი მოგვაქვს დაკავშირებული ცხრილიდან,
მაგ პროდუქტის მონაცემთან ერთად გამოგვაქვს პროდუქტის კატეგორიაც, მაშინ სისტემაზე მოდის იმდენი მოთხოვა რამდენი პროდუქტიც გვაქვს გამოტანილი + 1,
1 არის უშუალოდ ის მოთხოვნა რომლითაც ბაზიდან მოგვაქვს მონაცემები, ხოლო დანარჩენი კი არის მოთოვნა, რადგანაც დაკავშირებული ცხრილიდან მოგვაქ მონაცემი,
რადგანაც არ მოგვაქვს წინასწარ დაჯოინებული მონაცემი,
ამას ქვია n+1 მოთხოვნა, იმისათვის რომ მოთხოვნების რაოდენობა შევამციროთ მაშინ წინასწარვე დაჯოინებული მონაცემი უნდა წამოვიღთ

ამ პრობლემის გადასაჭრელად, viewშ, იმ ფილდში რომლიდანაც მოგვაქვს მონაცემი, წინასწარვე დავაჯოინოთ მონაცემი და ეს დაჯოინებული მონაცემი გამოვიტანოთ
ამას ვაკეთებთ .select_related('string')ით და ფრჩხილებში უნდა გადავცეთ დასახელება რომლითაც ერთ ცხრილს ვაკავშირებთ მეორესთან რომლიდანაც წამოიღებს დაკავშირებული ცხრილის მონაცემს
!!! თუკი ცხრილები დაკავშირებულია foreignkeyfieldით მაშინ უნდა გამოვიყენოთ selectrelated('')
!!! თუკი ცხრილები დაკავშირებულია manytomanyfieldით მაშინ უნდა გამოვიყენოთ prefetch_related('')



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
იმისათვის რომ მომხამრებელს შეეძლოს პროდუქტის გერდზე ატვირთვა, ამისათვის უნდა გამოაგზავნოს post მოთხოვნა
პირველ რიგში უნდა შევქმნათ ფორმა, form თეგს უნდა გავუწეროთ method='POST' რადგანაც მონაცემის შემოსატანა მომხმარებლს სჭირდება POST მოთხოვნა
ხოლო ეს post მოთხოვნა კი უნდა დავიჭიროთ viewებში



    <form action="">
        <input type="text" placeholder="product title">
    </form>
მაგრამ, მსგავსი სტატიკურდ ფორმის შექმნა არ გვჭირდება, ამიტომაც ვქმნით ახალ forms.py რომელშიც უნდა ავაწყოთ ფორმა
ამისათვის from django import forms მოდული უნდა დააიმპორტოთ, > მოდულთან ერთად models.pyდან მონაცემთა ბაზებიც უნდა დააიმპორტოთ
from store:models import Product, Category

შემდგომ უნდა ვქმნით კლასს, რომელიც არის forms.ModelForm კლასის შვილობილი
class ProductForm(forms.ModelForm):
ამავე კლასში უნდა შევქმნათ meta კლასი, რომელსაც უნდა გავუწეროთ რომელ მონცემებს ემუშავოს
    class Meta:
        model = 'Product'
        fields = []
        fields = "__all__"
        exclude = 'column_name' - გადაცემული სვეტის გარდა,
Modelმა ემუშავოს 'Product' ცვლადს
დაბლა კი ვუწერთ ცვლადში არსებული სვეტების დასახელებას, რომელიც უნდა გამოიტანოს შეგვიძლია [] ლისტის სახით გადავცეთ სვეტების დასახელება,
ან შეგვიძლია გადავცეთ "__all__" რომელიც ყველა ცხრილს გამოიტანს fieldsში

იმ შემთხვევაში თუ გვაქვს ასობით სვეტი და არ გვსურს ყველა სვეტის გამოტანა, მაშინ შეგვიძლია რომ გამოვიყენოთ exclude,
რომელსაც უნდა გადავცეთ იმ სვეტების ჩამონათვალი რომლის გამოტანაც არ გვსურს / იმ შემთხვევაში თუკი ისეთ ველს გადავცემთ რომელშიც მონაცემის შეყვანა აუცილებელია მაშინ გავა ერორზე
რადგანაც ბაზა მიიღებს შემოვყანილ სვეტში მიიღებს ნალ, მაგრამ ეს სვეტი აუცილებლად უნდა იყოს მონაცემით შევსებული, ბაზა გავა ერორზე



class ProductForm(forms.Form):
modelForm ის გარდა არსებობს Form იც მაგრამ, აქ სვეტები სათითაოდ უნდა ავღწეროთ მანუალურად




როდესაც შევქმნით ფორმა უნდა დავაიმპორტოთ viewებში
from app_name.forms import class_name
რა კლასებსაც შევქმნით ის კლასი უნდა დავაიმპორტოთ, როდესაც დავაიმპორტებთ ეს კლასი უნდა გამოვიყენოთ იმ ფუნქციაში რომელშიც ვქმნით viewsს გვერდს
ჯერ უნდა გავაკეთოთ ვალიდაცია რომ თუკი მოთხოვნა იქნება post მაშინ გაეშვას ეს ფორმა, ამისათვის ვიყენებთ if ბლოკს
if request == 'POST':
    მაშინ form უნდა გავუტოლოთ ამ კლასს რომელიც დავაიმპორტეთ, ხოლო ეს კლასი უნდა იყოს შევსებული requestდან შემოსული postით, ანუ მომხმარებლის მიერ შემოყვანილი მონაცემებით უნდა შეივსოს
    form = ProductForm(request.POST)
    შემდგომ ისევ ვწერთ ვალიდაციას if ბლოკით, რომ თუკი ფორმა იქნება ვალიდური მაშინ დასეივდეს ეს ფორმა
    if form.is_valid:
        form.save()
        როდესაც დასეივებდა უნდა დავაბრუნებინოთ, რომ ფომრიდან შემოსული მონაცემები გადამისამართდეს იმ გვერდზე სადაც პროდუქტები გამოგვაქ
        return redirect('store:products')
        გადასამისამართევლად ვიყენებთ redirect მეთოდს რომელიც უნდა დავაიმპორტოთ django.shortcutsდან render თან ერთად
    else:
    ხოლო თუკი მონაცემებში არ წამოვა post მოთხოვნა, მაშინ ფორმა მაინც შემოვიდეს მაგრამ იქნება ცარიელი და დაარენდეროს render ის სახით request და html დოკუმენტაცია
    def add_product(request):
    if request.method == "POST":
        form = ProductForm(request.POST)
        if form.is_valid():
            form.save()
            -- დასეივებამდე შეგვიძლია გადავცეთ commit=Flase, და მონაცემები არ დავასეივოთ მანამ სანამ ვერიფიკაციას არ გაივლის
            --დეფაულტად save(commit=True) არის True
            return redirect("store:product_list")
    else:
        form = ProductForm()
    აქ უნდა დავარენდერებინოთ request მოთხოვნა და html დოკუმენტი, რომელიც თუკი მოთხოვნის ფორმა იქნება არა post და სხვა, მაშინ გაეშვება ეს და გამპიტანს get მეთოდს
    return render(request, "add_product.html")

ბოლოს შექმნილი ფორმა უნდა გავატანოთ კონტექსტის სახით ფუქნციას, როგორც ბაზიდან წამოღებულ მონაცემს ვატანდით რათა ვიზუალურად გამოჩენილიყო,
ისევე მომხმარებლის მიერ შემოსული ფორმაც უნდა გავატანოთ, რათა ვიზუალურად გამოიტანოს

რადგანაც კონტექსტის სახით ვატანთ ამ ფორმას, ნაცვლად იმისა რომ სტატიკურად ავაწყოთ ფორმა შეგვიძლია პირდაპირ ეს ფორმა გამოვიტანოთ jinja2ის დახმარებით
{{ context_name }}
მაგრამ, აუცილებლად უნდა გამოვიყენოთ {% csrf_token %}, რადგანაც უშუალოდ ჯანგოს ფორმას ვიყენებთ და ამ ფორმა გამოატანს token,
csrf_token ის გარეშე ფორმა ვერ იმუშავებს














class ProductForm(forms.ModelForm):
-- აქაც შეგვიძლია სვეტების ხელით დამატება და მონაცემები შეყვანაც
    class Meta:
        model = Product
        fields = '__all__'
        exclude = ('is_active',)






