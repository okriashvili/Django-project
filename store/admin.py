from django.contrib import admin
# ამ გერდიდან ხდება admin გვერდთან დაკავშირებული ყველს ქმედებები და ოპერაციები
# რა გამოჩნდეს, რა მონაცემები გამოვიტანოთ და ა შ...

# djangoს superuserის შესაქმნელად საჭიროა რომ ტერმინალიდან გავუშვათ ბრძანება - python manage.py createsuperuser
# მას შემდეგ რაც შევქმნით superuserს, შეგვეძლება ჯანგოს ადმინისტრირება ამ ფეიჯიდან, sql ბაზაზე წვდომა / პროდუქტების დამატება / წაშლა და ა შ.
# აქედან შეგვიძლია მომამრებელა მივცეთ საიტზე წვდომის უფლება/შეზღუდა და ა შ.
# მთელი საიტის მართვააა შესაძლებელი
# მომხმარებლისთვის თანამშრომის სტატუსის / სუპეროუზერის სტატუსის მინიჭება / დაბლოკვა და ა შ.


from store.models import Category, Product


# admin.site.register([Category, Product])
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'price', 'quantity', 'categories', 'is_active', 'created_at']
    # list_dispay, ვიზუალურად გამოიტანს ყველა იმ მონაცემს რომელსაც ლისტის სახით გავუწერთ

    list_filter = ['created_at']
    # ფილტრაციას გააკეთებს, და ჩამონათვალლის გვერდით ცლკე გრაფაში გამოიტანს შედეგს

    list_display_links = ['title']
    # adminის გვერდმა კონკრეტული პროდუქტის გვერდზე გადასასვლელად რომელი მონაცემი გამოიყენოს,

    list_editable = ['price', 'quantity', 'categories', 'is_active']
    # რომელ სვეტსაც გადავცემთ იმ მონაცემის შეცვლა შეგვეძლება ისე რომ კონკრეტული მონაცემის გვერდზე არ გადავიდეთ
    actions = ['set_product_available', 'set_product_unavailable', 'set_product_discounted', 'set_FTU_discounted']

# Actions / ქმედებები - წინასწარ განსაზღვრული ფუნქცია, რომელიც საშუალებას გვაძლევს რომ გავაკეთოთ ცვლილებები
# დეფაულტად მოყვება წაშლის ქმედება, მაგრამ შეგვიძლია ჩვენივე ქმედება შევქმნათ და ის განახორციელოს
# ამისათვის უნდა შევქმნათ ფუნქცია და დავადოთ დეკორატორი, რასაც დეკორატორს გავუწერთ ის გახდება ქმედების დასახელება
    @admin.action(description='Set product available')
    # დეკორატორი უნდა დავადოთ  ფუქნციას თავზე
    def set_product_available(self, request, queryset):
        # ფუნქციას უნდა გადავცეთ self, request და queryset, query სეტს უდა გადავცეთ მეთოდი, ეს queryset იქონიებს გავლენას მონაცემეზე
        queryset.update(is_active=True)
    # ფრჩხილებში კი უნდა გადავცეთ თუკი რა ოპერაცია უნდა განახორციელოს
    # როდესაც შევქმნით ფუნქციას, ეს ფუნქცია უნდა ჩავსვათ ჩვენს კლასში საიდანაც მონაცემებს ვემუშავებით

    @admin.action(description='Set product unavailable')
    def set_product_unavailable(self, request, queryset):
        queryset.update(is_active=False)
        queryset.save()

    @admin.action(description='Set product discounted')
    def set_product_discounted(self, request, queryset):
        for product in queryset:
            product.price = int(product.price) * 0.80
            # რადგანაც product.price არის ათწილადი, გამრავლებით ვერ გაამრავლებს, ამიტომ ჯერ უნდა გადავიყვანოთ მთელ რიცხვში და შემდეგ გადავამრავლოთ
            product.save()


    @admin.action(description='Set discount for FTU')
    def set_FTU_discounted(self, request, queryset):
        for p in queryset:
            p.price = int(p.price) * 0.60
            p.save()




# models ფაილიდან დავაიმპორტეთ product და Category
# მაგრამ იმისათვის რომ admin გვერდზე გამოჩნდეს ვიყენებთ
# admin.site.register() - ფრჩხილებში ვუწერთ ცვლადის სახელს სადაც მონაცემებია შენახული
        # admin.site.register(product)
        # admin.site.register(Category)
# adminდან ვიძახებთ siteს და შემდეგ register
# ან შეგვიძლია ერთხელ გამოვიძახოთ და ლისტში ჩავსვათ
# admin.site.register([Product, Category])

# მას შემდეგ რაც ცვლადებს და მონაცემებს ავსახავთ admin გვერდზე, modelsფაილში, meta კლასში შეგვიძლია მივუთითოთ მონაცემის ცვალდის დასახელებაც>>>
# ამისათვის ვიყენებთ - verbal_name_plural='column_name' ამ ცვლადში გაწერილი სახელი აისახება admin ის გვერდზე
# ოღონდ ამას ვაკეთეთ models.py ფაილში


# მას შემდეგ რაც სვეტებში დავამატებთ მონაცემს, admin გვერდი მას ინახავს ობიექტის მისამართის სახელით(column_name object 1, column_name object 2 და ა შ...) და არა იმ დასახელებით რასაც ჩვენ შევიყვანთ,
# ამიტომ იმისათვის რომ არა ობიექტის მისამართით არამედ დასახელებით გამოჩნნდეს საჭიროა რომ გამოვიყენოთ str ან repr მეთოდი,
# როგორც კლასებში ვიყენებდით str და repr მეთოდს რომ ინსტასის გამოძახებისას გამოეტანა არ მისამართი არამედ დასახელება.
# ამასაც ვაკეთებთ models.py გვერდში



# Admin გვერდიდან მონაცემების დამატებას, არ სჭირდება მიგრაციის შექმნა და გაშვება, ამას ავტომატურად აკეთებს django
# ხოლო იმისათვის რომ ეს ყველაფერი admin გვერდიდან არ გავაკეთოთ და პითონის კოდის მეშვეობით დავამატოთ მონაცემები SQL ბაზაში, CRUD ოპერაციებისათვის ვიყენებთ ORM object related mapping

# მონაცემების პითონის კოდით შესატანად ტერმინალში უნდა გსმოვიძახოთ shell, python manage.py shell ბრძანებით
# shell ის გამოძახების შემდეგ კი models.py დან უნდა დავაიმპორტოთ ის მონაცემები რომელსაც ვინახავთ ამ ფაილში, იმავე სინტაქსით როგორ ფაილებში ვაიმპორტებთ from app_name.models import ...


# მას შემდედ რაც დავაიმპორტებთ შეგვიძლია განვახორციელოთ CRUD ოპერაციები

# მონაცემის დამატებს:
# მონაცემების შესაყვანად კი ვიყენებთ Tabble_name.objects.create() და ფრჩხილებში უნდა ჩავწეროთ მონაცემები
# Tabble_name.objects.create(column_name='' ბრჭყალებში უნდა დავუწეროთ მნიშვნელობა)
# რამდენი column იც გვაქვს იმდენ columnს უნდა გავუწეროთ მნიშვნელობა, წინააღმდეგ შემთხვევაში ერორზე გავა, თუკი ერთ სვეტსაც დავტოვებთ ცარილებს,
# იმ შემთხვევაში თუკი შესაძლოა nullable იყოს სვეტი შეგვიძლია ცარიელი დავტოვოთ.


# მონაცემის დასამატებლად მეორე მეთოდს ვიყენებთ:ცვლადში ვინახავთ უშუალოდ ცხრილს და ცვლადიდან ვიძახებთ სვეტს რომელსაც გავუტოლებთ მნიშვნელობას და შემდეგ ამ მნიშვნელობას დავასეივებთ
# cat = Category()
# cat.category_name = 'data'
# cat.save()



# რაც შეეხება product ცხრილს, რადგანაც დამოკიდებულია და დაკავშირებულია category ცხრილთან,
# იმისათვის რომ პითონიდან შევძლოთ მონაცემის ჩამატება, ჯერ საჭიროა foreign key დავიჭიროთ category ცხრილიდან, რათა productის მონაცემს მივანიჭოთ კატეგორია

################################################################################
# retrive
# მონაცემების წამოღება
# ამის გასაკეთებლად ჯერ უნდა წამოვიღოთ category id
# შეგვიძლია ცვალდში შევინახოთ category id და ეს ცვლადი გამოვიყენოთ productში მონაცემის დასამატებლადბრძანება,
# მონაცემის წამოსაღებად უნდა გამოვიყენოთ get ან all
# get() ბრძანება მხოლოდ ერთ მონაცემს წამოიღებს, ორ მონაცემზე დაერორდება

# all() ბრძანება ყველა მონაცემს წამოიღებს, ლისტში > დიქტის სახით
# შეგვიძლია FOR ციკლითაც გადავაიროთ ALLიდან წამოღებულ მონაცემებზე





# column_name.objects.filter() მეთოდით შეგვიძლია მონაცემების ფილტრაცია, ფრჩხილებში გადაეცემა ფილტრაციის ლოგიკა რის მიხედვითაც გაფილტრავს და დააბრუნეობს მონაცემს,
# თუკი მონაცემს ვერ იპოვის, მაშინ ერორზე არ გავა და ცარიელი ლისტი დაგვიბრუნდება,
# მძიმით შეგვიძლია გამოვყოთ ფილტრაციები, რომელიც იქნება და კავშირი
# მძიმით შეგვიძლია იმდენი ფილტრაცია გადავცეთ რამდენიც მოგვესურვება

# filter() ით ფიატრციის დროს შეგვიძლია იმდენ მონაცემზე გავაკეთოთ წვდომა რამდენიც მოგვესურვება, მაგრამ get() ით მხოლოდ ერთი მონაცემის წამოღება შეგვიძლია
# მაგრამ get() ფილტრაცია აბრუნებს ობიექტს, რომელზეც შეგვიძლია გამოვიყენოთ ატრიბუტები, ხოლო>>>
# filter() აბრუნებს querysetს, რომელზეც არ შეგვიძლია ატრიბუტების გამოყენება, ამიტომ მასზე უნდა გადავიაროთ for ციკლით, რის შემდეგაც შეგვიძლია მასზე ატრიბუტების გამოყენება

# first() და last() პირველ და ბოლო დამატებულ მონაცემს წამოიღებს

# ORMში არ ვვიყენებთ <> მეტობა ნაკლებობის ნიშნებს რიცხვებთან სამუშაოდ, მაგრამ ვიყენებთ: price__gt-მეტობა, price__gte-მეტია ან ტოლია / price__lt - ნაკლებობა, price__lte-ნაკლებია ან ტოლია

# tittle__startswith = '' და title__istartwith = '' - ბრჭყალებში გადაეცემა ის სიმბოლო რომლითაც უნდა იწყებოდეს მონაცემის დასახელება
# განსხვავება ამ ორ შორის ისაა რომ, istartwith რა სიმბოლოსაც გადავცემთ, ყურადღებას არ მიაქცევს დიდი ასოა თუ პატარა, მაინც მოძებნის
# ხოლო startwith თუკი გადავცემთ პატარა სიმბოლოს, მხოლოდ იმას დააბრუნებს რომელიც პატარა სიმბოლოთი იწყება

# title__contains='' და title__icontains='' - შეიცავს თუ არა მონაცემის დასახელება, ბრჭყალებში კი სიმბოლო(ები)ს კომბინაცია უნდა გადავცეთ,
# icontainsში გადაცემულ სიმობლოს მოძებნის პატარა და დიდ რეესტრშიც, მაგრამ contains უნდა გადავცეთ კონკრეტული სიმბოლო





# AND და OR კავშირები
# and ორ or კავშირით გადაბმული ფილტრაციისათვის არ ვიყენებთ and და or keywords, მაგრამ ვიყენებთ Q მოდელს
# Q უნდა დავაიმპორტოთ from django.db.models import Q
# filter() მეთოდში იწერება Q ბრძანება, რომელსაც უნდა გავუხსნათ () ფრჩხილები და Qის ფრჩხილებში უნდა გავუწეროთ ფილტრაციის ლოგიკა, ყოველი ფილტრაციის ლოგიკა უნდა დავწეროთ Qში
# თუ გვინდა რომ or კავშირით დავაკავშიროთ Qები უნდა გამოვყოთ | სწორი ხაზით
# product.objects.filter(Q(title__istartswith='Len') | Q(title__icontains='cle'))
# ხოლო თუ გვინდა რომ and კავშირით დავაკავშიროთ Qები, & და კავშირის სიმბოლო უნდა გამოვიყენოთ






# აგრეგირების ფუნქციები:
# აგრეგირების ფუნქციებისათვის საჭიროა რომ დავაიმპორტოთ Count, Avg, Min, Max, Sum
# from django.db.models import Count, Avg, Min, Max, Sum
# ამისათვის შეგვიძლია ცვლადში შევინახოტ მონაცემი და ამ ცვლადს მოვდოთ აგრეგირების ფუქნციები:
# product.objects.filter(title__icontains='en').aggregate(avg_price=Avg('price'))

# ან პირდაპირ დავასელექტოთ ფილტრაციით კონკრეტული მონაცემეი და აქედან ვემუშავოთ აგრეგირების ფუქნცციით
# exp_item = product.objects.filter(price__gte=150)
# exp_item.aggregate(total_price=Sum('price'))

# გადაეცემა aggregate() მეთოდი, რომელსაც ვუხსნით ფრჩიხლებს და ფრჩხილებში უნდა გადავცეთ ორი მნიშვნელობა:
# 1: სახელი რომელი სახელითაც გამოგვიტანს მონაცემს, ის უნდა დავუტოლოთ უშუალოდ აგრეგირების ლოგიკას
# 2: უშუალოდ აგრეგირების ლოგიკა, მეთოდის დასახელება და მეთოდის ფრჩხილებში უნდა გადავცეთ სვეტის სახელი
# aggregate(total_price=Sum('price'))
# საბოლოოდ კი გამოიტანს დიქტის სახით მონაცემს,
# key იქნება სახელი რაც გადავეცით
# value კი მნიშვნელობა რომელიც გამოაქვს აგრეგირების ფუნქციას

# აგრეგირების ფუნქციას გამოაქვს ათწილადის სახით მონაცემი, მაგრამ თუ გინდა რომ მთლიანი რიცხი გამოიტანოს შეგვიძლია round() მეთოდით დავამრგვალოთ
# ამისათვის, აგრეგირების ფუნქციის შედეგი შევინახოთ ცვლადში და ამ ცვლადე გამოვიყენოთ round() მეთოდი
# round(total_price['total_price'])
# round() მეთოდში უნდა გავუწეროთ ცვალდის სახელლი სადაც შევინახეთ წამოღებული მონაცემი,
# და ცვლადს კი ლისტის სახით უნდა გადავცეთ აგრეგირების ფუნქციის დროს დარქმეული სახელი,
# რომელიც keyის სახით გვიბრუნდება



########################## anotation / ანოტაციები
# ანოტაციების გასაკეთებლად ვიყენებთ anotate() მეთოდს, ანოტაციას ვიყენებთ იმისათვის რომ წამოვიღოთ ისეთი მონაცემები რომლის სვეტებიც არ გვაქვს შწქმნილი მონაცემთა ბაზაში / აღწერა გავაკეთოთ
# მაგ: დაითვლის პროდუქტებს კატეგორიის მიხედვით
# ამისათვის annotate() მეთოდი უნდა გამოვიყენოთ Category.objects.annotate() და ფრჩხილებში უნდა გავუწეროთ ანოტაცია/აღწერა
# ანოტაციაში კი ჯერ უნდა შევქმნათ ახალი ცვლადი რომელსაც გავუტოლებთ ანოტაციით წამოღებულ მნიშვნელობას და ამ ცვლადში შევინახავთ
# შემდგომ მაგ: დასათვლელად გამოვიყენოთ Count მეთოდი რომელიც დაითვლის პროდუქტებს და დააცალკევებს კატეგორიის მიხედვით
# count_cat = Category.objects.annotate(product_count=Count('product'))
# საბოლოოდ კი დაითვლის პროდუქტებს და გამოიტანს კონკრეტულ კატეგორიაში რამდენი მონაცემი გვაქვს
# რადგანაც foreignkey გვაქვს Categoryდან შეგვიძლია მივწვდეთ productსაც, და პირიქითაც productდან მივწდეთ Categoryს


# მაგ: თუკი გვინდა ფილტრაცია და productდან მივწვდეთ Category ან პირიქით შეგვიძლია:
# კონკრეტული კატეოგრია უნდა ამოვიღოთ > შემგომ for ციკლი გადავატაროთ იმ ცხრილის დასახელება რომელიც დაკავშირებულია, მაგრამ ცხრილის დასახელება პატარა ასოთი უნდა დავწეროთ + _set.all()
# for p in tech.product_set.all():
# მაგრამ ასეთი მიდგომა არის არასწორი და უმჯობესია > modelsში კავშირის შექმნისას გავუწეროთ related_names='name' >>
# და ეს სახელი შეგვიძლია გამოვიყენოთ ასეთ შემთხვევებში მონაცემების წამოსაღებად
# ამისათვის სინტაქსი იგივეა მაგრამ product_set ნაცვლად ვუწერთ related_names ში გაწერილ დასახელებას





###########################################################################################################
# update: მონაცემების განსანახლებლად ვიყენებთ: update() ბრძანებას რომელსაც ფრჩხილებში გადაეცემა 1:სვეტის დასახელება =''ბრჭყალებში უნდა გავუწეროთ და გავუტოლოთ ის მნიშვნელობა რომელითავ გვინდა განახლდებს მონაცემი
# update(description='lenovo laptops, 16GB RAM, 256GB storage')
# თუკი ფილტრაციას არ გამოვიყენებთ მაშინ ყველა მონაცემზე გააკეთებს წვდომას:
# მაგ:
# tech_product.filter(price__gte=1500).update(description='lenovo laptops, 16GB RAM, 256GB storage')
# update მთლიანად გაანახლებს მონაცემს, წინას წაშლის და ახალი გადაეწერება
# იმისათვის რომ წინა მონაცემი არ წაშალოს და ახალი გადააწეროს ძველს შეგვიძლია
# for ციკლი გადავიაროთ და დავასელექთოთ მონაცემი > შევინახოთ ცვლადში ცრილის ის სვეტი რომლის განახლებაც გვინდა > ცვლადში მოვახდინოთ მოდიფიკაციები >
# შემდგომ პირიქით ცხრილის სვეტი გავუტოლოთ ამ ცვლადს > და ბოლოს ეს ცვლადი დავასეივოთ
#  for product in tech_product.filter(price__gte=1500):
# ...     lenovo_desc = product.description
# ...     lenovo_desc += 'add description without removeing past information'
# ...     product.description = lenovo_desc
# ...     product.save()
# მაგრამ მსგავსი მიდგომა ძნელია
# მსგავსად შეგვიძლია მათემატიკური პოერაციების განხორციელებაც
# for p in Product.objects.all():
# for ციკლით გადავიაროთ მონაცემებზე
# ...     qt = p.quantity
# ცვლადში შევინახოთ კონკრეტული ცხრილის სვეტი რომელზეც გვინდა ოპერაციის შესრულება
# ...     qt += 3
# შევასრულოთ ოპერაცია, ამ შემთხვევაში რაოდენობა გავზარდოთ 3ით
# ...     p.quantity = qt
# პირიქით ამავე ცხრილის სვეტი გავუტოლოთ ამ ცვლადს
# ...     p.save()
# ბოლოს კი დავასეივოთ

# სვეტების გარეშე დასათვლელად და აგრეგირების გარეშე შეგვიძლია ცხრილში მონაცემების დათვლა>
# Product.objects.count()




################################################################################################
# delete / წაშლა ხდება delete() ბრძანებით
# ამისათვის ჯერ უნდა გავფილტროთ მონაცემები და ბოლოში მოვდიოთ delete() ბრძანება
# Product.objects.filter(categories=3).delete()




# მონაცემების დალაგება: order_by() ფრჩხილებში უნდა გადავცეთ სვეტის დასახელება, თუკი მხოლოდ სვეტს გადავცემთ მაშინ ზრდადობით დაალაგებს
# თუ გინდა რომ კლებადობის მიხედვით დაალაგოს მაშინ სცეტის დასახელების წინ უნდა დავუწეროთ მინუს (-) ნიშანი
# print(all_product.order_by('-price'))

















# actions / მოქმედებების შექმნა admin დან
# adminის გვერდზე მონაცემების გამოტანის ერთ-ერთი გზა არის admin.site.register([]) და ფრჩხილებში ლისტის სახით  გადავცეთ მონაცემებიდან წამოღებული ცხრიების დასახელება
# აგრეთვე შეგვიძლია კლასები შევქმნათ და იქიდან მივწვდეთ მონაცემებს

# კლასი უნდა იყოს adminიდან ModelAdmin ის შვილობილი კლასი
# იმისათვის რომ მივახვედროთ რომელ მოდელებს ემუშავოს, დეკორატორის სახით უნდა გადავცეთ კო კრეტული მოდელი რომელსაც უნდა ემუშავოოს




















