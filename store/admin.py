from django.contrib import admin
# ამ გერდიდან ხდება admin გვერდთან დაკავშირებული ყველს ქმედებები და ოპერაციები
# რა გამოჩნდეს, რა მონაცემები გამოვიტანოთ და ა შ...

# djangoს superuserის შესაქმნელად საჭიროა რომ ტერმინალიდან გავუშვათ ბრძანება - python manage.py createsuperuser
# მას შემდეგ რაც შევქმნით superuserს, შეგვეძლება ჯანგოს ადმინისტრირება ამ ფეიჯიდან, sql ბაზაზე წვდომა / პროდუქტების დამატება / წაშლა და ა შ.
# აქედან შეგვიძლია მომამრებელა მივცეთ საიტზე წვდომის უფლება/შეზღუდა და ა შ.
# მთელი საიტის მართვააა შესაძლებელი
# მომხმარებლისთვის თანამშრომის სტატუსის / სუპეროუზერის სტატუსის მინიჭება / დაბლოკვა და ა შ.

# from models import product, Category

from store.models import Category, product
# models ფაილიდან დავაიმპორტეთ product და Category
# მაგრამ იმისათვის რომ admin გვერდზე გამოჩნდეს ვიყენებთ
# admin.site.register() - ფრჩხილებში ვუწერთ ცვლადის სახელს სადაც მონაცემებია შენახული
        # admin.site.register(product)
        # admin.site.register(Category)
# adminდან ვიძახებთ siteს და შემდეგ register
# ან შეგვიძლია ერთხელ გამოვიძახოთ და ლისტში ჩავსვათ
admin.site.register([product, Category])

# მას შემდეგ რაც ცვლადებს და მონაცემებს ავსახავთ admin გვერდზე, modelsფაილში, meta კლასში შეგვიძლია მივუთითოთ მონაცემის ცვალდის დასახელებაც>>>
# ამისათვის ვიყენებთ - verbal_name_plural='column_name' ამ ცვლადში გაწერილი სახელი აისახება admin ის გვერდზე
# ოღონდ ამას ვაკეთეთ models.py ფაილში


# მას შემდეგ რაც სვეტებში დავამატებთ მონაცემს, admin გვერდი მას ინახავს ობიექტის მისამართის სახელით(column_name object 1, column_name object 2 და ა შ...) და არა იმ დასახელებით რასაც ჩვენ შევიყვანთ,
# ამიტომ იმისათვის რომ არა ობიექტის მისამართით არამედ დასახელებით გამოჩნნდეს საჭიროა რომ გამოვიყენოთ str ან repr მეთოდი,
# როგორც კლასებში ვიყენებდით str და repr მეთოდს რომ ინსტასის გამოძახებისას გამოეტანა არ მისამართი არამედ დასახელება.
# ამასაც ვაკეთებთ models.py გვერდში



# Admin გვერდიდან მონაცემების დამატებას, არ სჭირდება მიგრაციის შექმნა და გაშვება, ამას ავტომატურად აკეთებს django
# ხოლო იმისათვის რომ ეს ყველაფერი admin გვერდიდან არ გავაკეთოთ და პითონის კოდის მეშვეობით დავამატოთ მონაცემები SQL ბაზაში, CRUD ოპერაციებისათვის ვიყენებთ ORM object related mapping

# მონაცემების პითონის კოდით შესატანად ტერმინალში უნდა გსმოვიძახოთ shell, python manage.py shell ბრძანებით
# shell ის გამოძახების შემდეგ კი models.py დან უნდა დავაიმპორტოთ ის მონაცემები რომელსაც ვინახავთ ამ ფაილში, იმავე სინტაქსით როგორ ფაილებში ვაიმპორტებთ from app_name.models import ...

# მას შემდედ რაც დავაიმპორტებთ შეგვიძლია განვახორციელოთ CRUD ოპერაციები
# მონაცემების შესაყვანად კი ვიყენებთ Tabble_name.objects.create() და ფრჩხილებში უნდა ჩავწეროთ მონაცემები
# Tabble_name.objects.create(column_name='' ბრჭყალებში უნდა დავუწეროთ მნიშვნელობა)
# რამდენი column იც გვაქვს იმდენ columnს უნდა გავუწეროთ მნიშვნელობა, წინააღმდეგ შემთხვევაში ერორზე გავა, თუკი ერთ სვეტსაც დავტოვებთ ცარილებს,
# იმ შემთხვევაში თუკი შესაძლოა nullable იყოს სვეტი შეგვიძლია ცარიელი დავტოვოთ.


# მონაცემის დასამატებლად მეორე მეთოდს ვიყენებთ:ცვლადში ვინახავთ უშუალოდ ცხრილს და ცვლადიდან ვიძახებთ სვეტს რომელსაც გავუტოლებთ მნიშვნელობას და შემდეგ ამ მნიშვნელობას დავასეივებთ
# cat = Category()
# cat.category_name = 'data'
# cat.save()



# რაც შეეხება product ცხრილს, რადგანაც დამოკიდებულია და დაკავშირებულია category ცხრილთან,
# იმისათვის რომ პითომიდან შევძლოთ მონაცემის ჩამატება, ჯერ საჭიროა foreign key დავიჭიროთ category ცხრილიდან, რათა productის მონაცემს მივანიჭოთ კატეგორია

# ამის გასაკეთებლად ჯერ უნდა წამოვიღოთ category id
# შეგვიძლია ცვალდში შევინახოთ category id და ეს ცვლადი გამოვიყენოთ productში მონაცემის დასამატებლადბრძანება,
# მონაცემის წამოსაღებად უნდა გამოვიყენოთ get ან all
# get() ბრძანება მხოლოდ ერთ მონაცემს წამოიღებს, ორ მონაცემზე დაერორდება

# all() ბრძანება ყველა მონაცემს წამოიღებს, ლისტში > დიქტის სახით
# შეგვიძლია FOR ციკლითაც გადავაიროთ ALLიდან წამოღებულ მონაცემებზე

