from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, JsonResponse
from store.models import Product, Category
from store.forms import ProductForm
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView, TemplateView
from django.urls import reverse_lazy

# ListView - გამოიყენება მონაცემების სიის გამოსატანად
# DetailView - გამოიყენება მონაცემების დეტალების გამოსატანად
# CreateView - გამოიყენება მონაცემების დასამატებლად


# views.py ვწერთ ფუნქციების სახით ლოგიკებს რომლებიც მომხმარებლისთვის ვიზუალურად იქნება ხილული.
# მას შემდეგ რაც ამ ფუნქციას შევქმნით, იმისათვის რომ უშუალოდ ვიზულურად გამოვიტანოთ ბრაუზერში,
# ფუნქციის დასახელება უნდა გავწეროთ urls ფაილში urlpatterns ლისტში,
# სადაც უნდა შევუქმნათ ენდფოინთი და ამ ფუნციის დასახელება გავუწეროთ, რათა ენდფოინთის გამოძახებისას უშუალოდ ამ ფუნქციას მიაკითხოს

        # def index(request):
        #     # ფუნქციას აუცილებლად უნდა გადავცეთ request პარამეტრი
        #     return HttpResponse("<h1>Hello, world. You're at the polls index.</h1>")
# ბოლოს კი  httpresponse ში უნდა დავაბრუნებინოთ მონაცემი რასაც ვიზუალურად გამოიტანს, შეგვიძლია html ის კოდიც გავწეროთ შიგნით

        # def about(request):
        #     return HttpResponse("<h2>Hello, world. You're at the polls about.</h2>")
# მაგრამ ის მიგდომა რომ html კოდი httpresponseში დავწეროთ არის არასწორია
# ამიტომ შეგვიძლია ცალკე html კოდი დავწეროთ და უშუალოდ ეს კოდი დავარენდეროთ ფუნქციაში,
# ამისათვის ვიყენებთ დაიმპორტებულ render და არა httpresponse
# def index(request):
#     # მსგავსად httpresponseისა, უნდა გადავცეთ request პარამეტრი,
#     return render(request, "index.html")
# # ხოლო renderს კი უნდა დავაბრუნებინოთ request და html ფაილი,
# # ამისათვის, აუცილებლად უნდა შევქმნათ template საქაღალდე, რომელშიც უნდა შევინახოთ html ფაილები, საქაღალდეს აუცილებლად უნდა დავარქვათ templates

class HomeView(TemplateView):
    template_name = 'index.html'



    # def about(request):
            # return render(request, "about.html")
# ხოლო, შეგვიძლია about გვერდიც ისევე ავაწყოთ როგორც IndexView
    # class AboutView(TemplateView):
    #     template_name = 'about.html'
# მაგრამ, შეგვიძლია კლასი არ შევქმმნათ და უშუალოდ urlsში დავაიმპორტოთ TemplateView, და TemplateView.as_view()ს ფრჩხილებში გადავცეთ
# template_name='about.html', ფრჩხილებში უნდა გადავცეთ ის template რაც უნდა დაამუშავოს
# უშუალოდ pathშივე უნდა გავუწეროთ



# index და aboutის შემთხვევაში, რომელიც მონაცემებს არ ემუშავება და მხოლოდ კონკრეტული ფაილი გამოაქვს
# შეგვიძლია გამოვიყენოთ TemplateView













# #############################################################################################################################
# ბაზიდან მონაცემების წამოღება და ამ მონაცემების გამოსახვა ჩვენს გვერდზე, ამისათვის ჯერ models ფაილიდან უნდა დავაიმპორტოთ მონაცემები
# შემდეგ კი ORM ის საშუალებით უნდა წამოვიღოთ ეს მონაცემები ფუნქციაში
def products_json(request):
    all_products = Product.objects.all()
    # ბოლოს კი JsonResponseთი უნდა დავაბრუნებინოთ, Json ობიექტის სახით გარდაქმნიოს მონაცემებს და ისე გამოიტანს
    return JsonResponse({'products_json' : list(all_products.values())})
    # ლისტად გადავაქციეთ ეს მონაცემები რათა სერიალიზაციის დროს Jsonმა წაიკითხოს და დააბრუნოს
    # რადგანაც all_product ჩვენს მიერ დაწერილი კლასია, ვერ დაასერიალიზებს

# მაგრამ იმისათვის რომ ჩვენვე წამოვიღოთ ეს მონაცემი და ვიზუსლურად გამოვიტანოთ საიტზე, ამისათვის საჭიროა რომ contextით გავატანოთ ეს მონაცემი
# contextში ის ცვლადი უნდა გავატანოთ რომელშიც ORMით წამოღებული მონაცემები გვაქვს შენახული, ხოლო უშუალოდ ამ მონაცემის გამოსახვა კი უნდა მოხდეს html დოკუმენტიდან jinjaს ენის საშუალებით
        # def product_list(request):
        #     all_product = Product.objects.all().select_related('categories').order_by('-created_at')
        #     total_products = all_product.count()
        #     return render(request, "products.html", {'products' : all_product})
# <!--  იმისათვის რომ ბექიდან წამოღებული მონაცემი გამოვსახოთ ვიყენებთ ჯინჯას ენას, context ით გამოტანებული ცვლადის გამოსახვა შეგვიძლია {{ context_name }} ით,
# მაგრამ გამოიტანს query_setს დიქტის სახით, იმისათვის რომ დალაგებული და ვიზუალურად გარჩევადი იყოს შეგვიძლია გადავიაროთ for ციკლით და სათითაოდ გამოვიტანოთ ისინი  -->
# <!-- for ციკლიცთვის ან if ბლოკისათვის ვიყენებთ {% %} ფიგურული ფრჩხილები და პროცენტის ნიშანი შიგნით, ხოლო ცვლადის გამოსატანად კი უშუალოდ {{}} ორი ფიგურული ფრჩხილები  -->
# შეგვიძლია forიდან ამოღებულ მონაცემების ატრიბუტებიც გამოვიტანოთ მხოლოდ




# როგორც ვიცით viewsში ფუნქციებში იწერება ლოგიკები, რომელიც ვიზუალურაად გამოიტანს ფაილებში დაწერილ დოკუმენტაციას
# მაგრამ, გარდა ფუნქციებისა შეგვიძლია კლასებშიც გავწეროთ ეს ლოგიკები, რასაც პროგრამირებაში ვუწოდებთ classed_based_view CBV
# ეს CBV ჩაშენებულია djangoში, რომელის შესაძლებლობები შეგვიძლია გამოვიყენოთ ჩვენს მიერ შექმნილ viewში
# ჯერ უნდა დავაიმპორტოთ viewები from django.views.generic import Views
# productეის გვერდი გადავაკეთოთ CBVად
class ProductListView(ListView):
    # model ში უნდა გადავცეთ იმ მოდელის/ცხრილის დასახელება რომელიც უნდა გამოსახოს, რომელი მოდელიდანაც გვინდა მონაცემის წამოღება
    model = Product

    # template_nameს უნდა გადავცეთ html ის ფაილი, რომელშიც უნდა გამოსახოს ეს მონაცემი
    template_name = "products.html"

    # context_objects_name როგორც ფუნქციაში ვაბრუნებინებდით კონტექსტის სახით მონაცემებს, რომელსაც შემდგომ ვიყენებდით მონაცეების გამოსასახად, მსგავსად
    context_object_name = "products"
    # დეფაულტად context_object_name დააბრუნდეს იმ მოდელის ყველა პროდუქციას, რომლსაც model = ში გადავცემთ
    # ამის ფუნქციონალი გაწერილი აქვს მშობელ კლასში / ან შეგვიძლია context_processorsში გავატანოთ მონაცემი
    # იმ შემთხვევაში თუკი, კლასიდან გადავატნთ მონაცემს და არა context_processorsდან, მაშინ მოთხოვნების შესამცირებლად querysetში უნდა გავიწეროთ select_related()
    queryset = Product.objects.all().select_related('categories')
    # პირდაპირ select_raletedს ვერ მოვდებთ, ჯერ წვდომა უნდა განვახორციელოთ Productზე და მერე მოვდოთ

    # პაგინაცია აკეთებს რომ ერთ გვერდზე მაქსიმუმ რამდენი პროდუქტი უნდა გამოიტანოს, ალაგებს პროდუქციას რაღაც ლოგიკის მიხედვით,
    paginate_by = 6 # ერთ გვერდზე გამოიტანს მხოლოდ 3 პროდუქტს, დანარცენის ნახვა კი სხვა გვერდებზე იქნება შესაძლებელი
    # პაგინაციის ენდფოინთი იწერება ?page=N რომელ გვერდზეც ვართ იმის ნომერი გაეწერება nში

    # პაგინაციების გვერდის შექმნა კი ხდება html დოკუმენტაციაში
    # პაგინაციას გაჩნია რამდენიმე ჩაშენებული ცვლადიც:
    # is_paginated - გვაქვს თუ არა პაგინაცია გაკეთებული
    # num_pages - რამდენი გვერდი გვაქვს
    # page_obj.number - რომელ გვერდზეც ვართ იმას გამოიტანს
    # object_list - არსებულ გვერდზე მონაცემებს გამოიტანს query_setის სახით
    # page_obj -რამდენი გვერდიცაა, ამ გვერდებიდან რომელ გვერდზე ვართ ჩვენ - ანუ მაგ თუა 3 გვერდი და ვართ 2 გვერდზე გამოიტანს რომ ვართ page 2 of 3
    # page_obj.has_previous - რომელ გვერდზეც ვართ, იმ გვერდს აქვს თუ არა წინა გვერდი
    # page_obj.has_next - რომელ გვერდზეც ვართ, იმ გვერდს აქვს თუ არა შემდეგი გვერდი

    # page_obj.previous_page_number - რომელ გვერდზეც ვართ იმ გვერდს თუ აქვს წინა გვერდი ამ გვერდის ნომერს გამოიტანს
    # page_obj.next_page_number - რომელ გვერდზეც ვართ იმ გვერდს თუ აქვს შემდეგი გვერდი ამ გვერდის ნომერს გამოიტანს
    # ზემო ორი ცვლადის შემთხვევაში თუ ვართ პირველ ან ბოლო გვერდზე, რადგანაც მათ არ აქვთ წინა ან შემდეგი გვერდი, გავა ერორზე

    # paginator.page_range - რამდენ გვერდიც გვაქვს იმ გვერდების რეინჯს გამოიტანს, როგორც range ფუნქცია მუშაობდა ისე იმუშავებს




    # იმ შემთხვევაში თუკი კლასსს ერთზე მეტი მოდელი უნდა გავატანოთ,
    # მაგ: კლასს productების გარდა უნდა გავატანოთ ბოლოს დამატებული 5 პროდუქცია, ამისათვის ვიყენებთ არა context_objects_manager არამედ ვიყენებთ მეთოდს def context_data
    def get_context_data(self, **kwargs):
        # მეთოდმა ჯერ მშობლის მონაცემები უნდა წამოიღოს, და შემდეგ გადავუტვირთოთ
        context = super().get_context_data(**kwargs)
        # superით უნდა გამოვიძახოთ მშობლის მეთოდი და გადავტვირტოთ

        # ისევ context უნდა გადავტვირთოთ,1: ჯერ ცვლადს უნდა გავუწეროთ პირდაპირ context სახელი, რომელსაც კონტრქსტით გატანს და უშუალოდ ამას გამოვიყენებთ html კოდში
        # 2: context უნდა გადავტვირთოთ და ახალი მონაცემი გავატანოთ
        context['last_five_product'] = self.queryset.order_by('-created_at')[:5]
        context['count'] = self.queryset.count()
        # ყოველი ახალი მონაცემის გამოსატანად, contextს უნდა გავუწეროთ ['context_name']  = ახალი მონაცემის წამოღება
        # ბოლოს კი context უნდა დავაბრუნოთ
        return context


    # ordering = გადაეცემა მნიშვნელობა, რომლის მიხედვითაც დაალაგებს ჩვენს მონაცემეს, შეგვიძლია გადავცეთ ფასი, სახელი, შექმნის დრო, ხელმისაწვდომობა და ა შ.
    # ordering = ['-created_at']

# მას შემდეგ რაც ავაწყობთ CBVს, urlsშიც უნდა შევუცვალოთ პარამეტრები, კონკრეტულად ფუნქციიდან უნდა გადავაკეთოთ კლასად და pathში კლასი უნდა გავუწეროთ
# მაგრამ pathში პირდაპირ კლასს ვერ გავუწერთ, არამედ კლასი უნდა გამოვიძახოთ, ბოლოში უნდა გავუწეროთ class_name.as_view() - as_view() უნდა გავუწეროთ




# მონაცემის დამატება:
# def add_product(request):
#     if request.method == "POST":
#         form = ProductForm(request.POST)
#         if form.is_valid():
#             form.save()
#             return redirect("store:product_list")
#     else:
#         form = ProductForm()
#     return render(request, "add_product.html", {'form' : form})


# გადავტვირთოთ add_productიც classებად
class ProductCreateView(LoginRequiredMixin, CreateView):
    model = Product
    template_name = "add_product.html"
    # განსხვავებით ფუნქციისა არაა საჭირო გავუწეროთ if ბლოკი, requestის ფრომა და ა შ

    # მარტივად უნდა გადავცეთ ფორმის კლასი
    form_class = ProductForm

    # მონაცემის დამატების შემთხვევაში რომელ გვერდზე გადაგვიყვანოს, აწ ვუწერთ ენდფოინთის დასახელებას
    def get_success_url(self, **kwargs):
        return reverse_lazy("store:product_details", kwargs={'product_pk': self.object.pk})

    # თუკი მომხმარებელი არ არის დალოგინებული მაშინ გადაიყვანოს login ფეიჯზე
    login_url = 'user:login'

# LoginRequiredMixin გამოიყენება იმისათვის რომ, კონკრეტული მოქმედების შესრულება შეეძლოს იმ მომხმარებლებს რომლებიც არიან დალოგინებულები
# ოღონდ ჯერ უნდა დავაიმპორტოთ - from django.contrib.auth.mixins import LoginRequiredMixin

# ამის ვალიდაციას აკეთებს, თუკი მომხმარებელი არ არის დალოგინებული, არ შეეძლება კონკრეტული მოქმედების შესრულება და უნდა გადაამისამართებს რეგისტრაციის ან ლოგინის გვერდზე
# გადამისამართებას კი ვაკეთებთ login_url ით და reverse_lazy ან პირდაპირ იმ გვერდის url სადაც უნდა გადამისამართდეს






# # მონაცემის აფდეითი
# def update_product(request, product_pk):
#     # ჯერ უნდა წამოვიღოთ, ის მონაცემი რომლის აფდეითიც გვინდა, ამისათვისაც pkის ვიყენებთ
#     product = get_object_or_404(Product, pk=product_pk)
# # პდორიქტის დამატების მსგავსად, აქაც უნდა წამოვიდეს post მეთოდი
#     if request.method == "POST":
#         # როდესაც წამოვა post მეთოდი მაშინ დააბურნოს productForm(რომელიც შევქმნეით ფორმებში) > request.POSTიდან წამოღებული მონაცემი
#         # და პლიუს უნდა დავამატოთ instance=product დასახელებული არგუმენტი
#         # როდესაც ეს მოთხოვნა წამოვა, instance=product ამოიღებს პროდუქციის მთელ ინფორმაციას რომელიც ადრე შევავსეთ, და შეგვეძლება უშუალოდ ამ მონაცემების შეცვლა,
#         # რათა თავიდან არ მოგვიწიოს ყველა ველის შეცვლა, მხოლოდ იმ სვეტს შევცვლით რომელიც გვინდა
#         form = ProductForm(request.POST, instance=product)
#         # როდესაც from ამოიღებს productს, უდა გავატართ ისევ ვალიდაციის ლოდიკა
#         if form.is_valid():
#             form.save()
#             # redirect ში იწერება ლოგიკა, რომლითაც როდესაც მოხდება მონაცემის დააფდეითება ან დამატება, რომელ გვერდზე დაგვაბრუნოს ამ ოპერაციის შემდეგ
#             # როგორც ჯინჯაში ისე ვუწერთ აქაც მისამართს, მაგრამ თუკი კონკრეტულ გვერდს ესაჭიროება pkიც,
#             # მაშინ უნდა გავუწეროთ რომ product_pk იყოს ის ცვლადი რომლითაც ვიღებთ ამ კონკრეტული გვერდისთვის pk ის
#             return redirect("store:product_details", product_pk=product_pk)
#     else:
#         form = ProductForm(instance=product)
#         # elseში fromს ისევ უნდა გადავცეთ ProductForm(instance=product), რათა ცარიელი ფორმის ნაცვლად დააბრუნოს ის ფორმა რომელიც წაიღო დასააფდეითებლად, მაგრამ ვერ დააფდეითა
#     return render(request, "update_product.html", {'form' : form})
#     # საბოლოოოდ კი ისევ ვარენდერებთ ფუნქციას

# აფდეითის შემდეგ პროდუქტს დაალაგებს იმის მიხედვით თუკი რომელი პროდუქტი შემოვიდა ბოლოს, ამიტომაც დააფდეითებულ პროდუქციას ბოლოში ჩააგდებს,
# ამისათვის გავქვს შემდეგი მიდგომა რომ, იმ ცვლადში რომელშიც ვიღებთ პროდუქციას, ბოლოს მოვდოთ .order_by(' ') მეთოდი,
# ფრჩხილებში კი დალაგების ლოდიკა უნდა გადავცეთ, რომელიც გავიარეთ shellში

class ProductUpdateView(UpdateView):
    model = Product
    template_name = "update_product.html"
    form_class = ProductForm

    # updateის შემთხვევაში სჭირდება pk_urls_kwarg, რათა დავიჭიროთ მონაცემი კონკრეტული აიდის მიხედვით და ეს კონკრეტული მონაცემი დავააფდეითოთ
    pk_url_kwarg = 'product_pk'

    # აფდეითის შემდეგ, უნდა გადაგვამისამართოს ამ პროდუქტის დეტალურ გვერდზე მაგრამ დეტალურ გვერდს სჭირდება ამ პროდუქტის აიდი,
    # რათა კონკრეტულ პროდუქტის დეტალიურ გვერდზე გადავიდეთ
    # ამ შემთხვევაში success_url უნდა გადავუტვიირთოთ მეთოდი, რადგანაც უშუალოდ success_urlს ვერ გადავცემთ კონკრეტული პროდუქტის აიდის
    # success_url = '/products/'
    # შეგვიძლია redirect გამოიყენოთ და გადავცეთ დეტალური გვერდის მისამართი და product_pk,
    # success_url = redirect('store:product_details', product_pk = 1)
    # მაგრამ პარამეტრად product_pk ვერ გავუტლოებთ უშუალოდ დააფდეითებული მონაცემის აიდის, ფუნქციისგან განსხვავებით ამ მონაცემის აიდი არ შემოგვაქვს

    # ამიტომაც უნდა გადავუტვირთოთ success_url
    def get_success_url(self, **kwargs):
        # გადატვირთვისას უნდა დავაბრუნებინოთ reverse_laze, რომელიც ჯერ უნდა დავაიიმპორტოთ from django.urls import reverse_lazy
        return reverse_lazy ("store:product_details", kwargs={'product_pk': self.object.pk})
        # reverse_lazy()-ს
        # 1:ჯერ უნდა გავუწეროთ იმ html ფაილი მისამართი, რომელზეც უნდა გადაგვამისამართოს
        # ამ შემთხვევაში "store:product_details", შემდეგ>>>
        # 2: რადგანაც სჭირდება ამ მონაცეკონკრეტული მონაცემის აიდი, უნდა გავუწეროთ kwargsში რომ
        # 'product_pk' იყო ამ ობიექტის pk, ანუ: pk_url_kwargში გადაცემული product_pk გახდეს, იმ პროდუქტის pk რომელსაც ვააფდეითებთ

# გადავწეროთ მონაცემის განახლების ლოგიკაც კლასზე





# # წაშლა
# def delete_product(request, product_pk):
#     # წაშლის შემთხვევაშიც კონკრეტული პროდუქტის აიდით გვჭირდება მონაცემის ამოღება,
#     product = get_object_or_404(Product, pk=product_pk)
#     # აქაც ისევ უნდა შემოვიდეს POST მოთხოვნა
#     if request.method == "POST":
#         # პირდაპი უნდა მოვდოთ delete() მეთოდი
#         product.delete()
#         return redirect("store:product_list")
#     # წაშლის შემთხვევაში არ ვარენდერებთ პროდუქციია, არამედ ვუწერთ redirect, გადამისამართებას
#     # რადგანაც მონაცემს ვშლით, მომხმარებელი უნდა გადამისამართდეს სხვა გვერდზე
#     return redirect(request, "products.html", {'product' : product})
# შედარებიტ განსხვავებულია წაშლის ლოდიკა, ამ შემტხვევაში არ გვჭირდება ახალი html დოკუმენტაცია,
# არამედ შეგვიძლია მხოლოდ ღილაკი შევქმნათ მონაცემის წასაშლელად,
# ამისათვის ისევ ვქმნით urls ისევე რათა ავამუშავოთ ის ფუქნცია რომელიც უნდა გამოვიყენოთ წასაშლელად
# ხოლო html ფაილში უნდა შევქმნათ formით ღილაკი, რათა post მეთოდი გავუშვათ
# ისევ ვიყენებთ {% csrf_token %} რათა გაეშვას ჩვენი ფორმა
# ხოლო urls ლინკი რომლელზეც უნდა დასაბმითდეს, უნდა გავუწეროთ action="{% ურლ %}" ში ჯინჯას ენით{%%}
# იმისათვის რომ ეს submit ღილაკი ამუშავდეს, უნდა გავუწეროთ რომელ ლინკზე უნდა გაიგზავნოს, რომელიც შევქმენით urls.pyში

# formს შეგვიძლია გავუწეროთ on_submit("return confirm('')") - რომელიც გააკეთებს რომ როდესაც გავუშვებთ წაშლის ფუნქციას,
# ამოგვიგდებს პატარა ფანჯარას რომელში უნდა დავადასტუროთ რომ გვსურს თუ არა ნამდვილად წაშლა
# დადასტურების შემთხვევაში გაეშვება და წაიშლება, ხოლო დაქენსელების შემთხვევაში ფუნქცია შეწყვეტს მუშაობას

# გადვწეროთ წაშლის ფუნქციაც კლასად
class ProductDeleteView(DeleteView):
    # წასაშლელად დაგვჭირდება მხოლოდ model, რომელ მოდელს ემუშავოს კლასი
    model = Product

    # pk_url_kwarg რათა კონკრეტული მონაცემი ამოვიღოთ
    pk_url_kwarg = 'product_pk'

    # ბოლოს იმ გვერდის მისაამრთი, სადაც უნდა დაბრუნდეს წაშლის დროს
    success_url = "/products/"










# იმისათვის რომ კონკრეტული პროდუქტისნ მთლიანი მონაცემი გამოვიტანოთ ამისათვისაც უნდა შევქმნათ ახალი გვერდი, სადაც უშუალოდ ერთი პროდუქტის მთლიან მონაცემს გამოიტანს
# ყოველ პროდუქტს სათთაოდ არ შევუქმნათ ახალი გვერდი, უმჯობესია რომ ერთი გვერდი შევქმნათ სადაც იმ პროდუქტის მონაცემს გამოიტანს რომელიც მომხმარებელს სურს
# ამისათვის ჯერ კონკრეტული პროდუქტზე უნდა განვახორციელოთ წვდომა, რისთვისაც ვიყენებთ pk ან id,
# მონაცემის id უნდა დავიჭიროთ რომელი პროდუქტის აიდისაც დავიჭერთ იმ პროდიქტის მონაცემებს გამოიტანს ამ გვერდზე
# ფუქნციას requestთან ერთად, მეორე პარამეტრიც უნდა გადავცეთ idის სახით, რასაც ძირითადად ვარქმევთ product_pk,
# ამ გვერდის ენდფოინთთან ერთად რომელი პროდუქტის აიდიც წამოვა იმ პროდიუქტის მონაცემებს გამოვიტანთ

# product ისგან განსხვავებით აქ უნდა გავფილტროთ და მონაცემი ამოვიღოთ id ით და ეს id უნდა გავუტოლოთ ჩვენს მიერ გადაცემულ პარამეტრს,
# რათა ეს წამოღებული id დაიჭიროს პარამეტრმა და ამ idის მონაცემი გამოვიტანოთ
        # def product_details(request, product_pk):
        #     product = get_object_or_404(Product, id=product_pk)
        #     return render(request, "product_details.html", {'product' : product})



# გადავაკეთოთ product_details კლასად, ამისათვის ვიყენებთ DetailViewს, ჩვენი კლასი უნდა გავხადოთ DetailViewს შვილობილი
class ProductDetailView(DetailView):
    model = Product
    template_name = "product_details.html"
    # მაგრამ რადგანაც product_detailზე კონკრეტული პროდიქტის აიდით გადავყავართ და აქ არ გვაქვს გაწერილი რომ ეს აიდი ამოიღოს
    # ამ შემთხვევაში ეს გვერდი დაერორდება, ამიტომაც ვიყენებთ pk_url_kwargს და მნიშვნელობად უნდა გადავცეთ product_pk
    # pk_url_kwarg = "product_pk"
    # დეფაულტად pk_url_kwarg მნიშვნელობად აქვს pk
    # თუკი არ გინდა რომ pk_url_kwarg გადავუტვირთოთ და დავტოვოთ, მაშინ urlში > pathში > routeში უნდა გავუწეროთ რომ მიიღებს ენდოფოინთში მიიღებს არა  product_pkს არამედ pk
    pk_url_kwarg = "product_pk"



    # მიუხედავად იმისა რომ html ში კონტექსტით არ ვატანთ წამოღებულ მონაცემებს, html ფაილი კონტექსტის სახელად იყეებს {{ product }}
    # ესეც, ჩაშენებულია DetailViewში, რომ თუკი კლასს არ გავუწერთ context_object_nameს,
    # კლასი modelში გადაცემულ მნიშვნელობას გამოიყენებს context_nameდ, პატარა რეესტრში გადმოიყვანს და იმას გამოიყენებს,
    # ან მიუხედავად იმისა context_object_name გადავუტვირთავთ თუ არა, დეფაულტად djangoს უწერია რომ შეგვიძლია გამოვიყენოთ object context_nameად მაინც იმუშავებს
    context_object_name = "product"
0
















