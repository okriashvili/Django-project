from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, JsonResponse
from store.models import Product, Category
from store.forms import ProductForm


# views.py ვწერთ ფუნქციების სახით ლოგიკებს რომლებიც მომხმარებლისთვის ვიზუალურად იქნება ხილული.
# მას შემდეგ რაც ამ ფუნქციას შევქმნით, იმისათვის რომ უშუალოდ ვიზულურად გამოვიტანოთ ბრაუზერში,
# ფუნქციის დასახელება უნდა გავწეროთ urls ფაილში urlpatterns ლისტში,
# სადაც უნდა შევუქმნათ ენდფოინთი და ამ ფუნციის დასახელება გავუწეროთ, რათა ენდფოინთის გამოძახებისას უშუალოდ ამ ფუნქციას მიაკითხოს

        # def index(request):
        #     # ფუნქციას აუცილებლად უნდა გადავცეთ request პარამეტრი
        #     return HttpResponse("<h1>Hello, world. You're at the polls index.</h1>")
# ბოლოს კი  httpresponse ში უნდა დავაბრუნებინოთ მონაცემი რასაც ვიზუალურად გამოიტანს, შეგვიძლია html ის კოდიც გავწეროთ შიგნით

        # def about(request):
        #     return HttpResponse("<h2>Hello, world. You're at the polls about.</h2>")
# მაგრამ ის მიგდომა რომ html კოდი httpresponseში დავწეროთ არის არასწორია
# ამიტომ შეგვიძლია ცალკე html კოდი დავწეროთ და უშუალოდ ეს კოდი დავარენდეროთ ფუნქციაში,
# ამისათვის ვიყენებთ დაიმპორტებულ render და არა httpresponse
def index(request):
    # მსგავსად httpresponseისა, უნდა გადავცეთ request პარამეტრი,
    return render(request, "index.html")
# ხოლო renderს კი უნდა დავაბრუნებინოთ request და html ფაილი,
# ამისათვის, აუცილებლად უნდა შევქმნათ template საქაღალდე, რომელშიც უნდა შევინახოთ html ფაილები, საქაღალდეს აუცილებლად უნდა დავარქვათ templates

def about(request):
    return render(request, "about.html")



# #############################################################################################################################
# ბაზიდან მონაცემების წამოღება და ამ მონაცემების გამოსახვა ჩვენს გვერდზე, ამისათვის ჯერ models ფაილიდან უნდა დავაიმპორტოთ მონაცემები
# შემდეგ კი ORM ის საშუალებით უნდა წამოვიღოთ ეს მონაცემები ფუნქციაში
def products_json(request):
    all_products = Product.objects.all()
    # ბოლოს კი JsonResponseთი უნდა დავაბრუნებინოთ, Json ობიექტის სახით გარდაქმნიოს მონაცემებს და ისე გამოიტანს
    return JsonResponse({'products_json' : list(all_products.values())})
    # ლისტად გადავაქციეთ ეს მონაცემები რათა სერიალიზაციის დროს Jsonმა წაიკითხოს და დააბრუნოს
    # რადგანაც all_product ჩვენს მიერ დაწერილი კლასია, ვერ დაასერიალიზებს

# მაგრამ იმისათვის რომ ჩვენვე წამოვიღოთ ეს მონაცემი და ვიზუსლურად გამოვიტანოთ საიტზე, ამისათვის საჭიროა რომ contextით გავატანოთ ეს მონაცემი
# contextში ის ცვლადი უნდა გავატანოთ რომელშიც ORMით წამოღებული მონაცემები გვაქვს შენახული, ხოლო უშუალოდ ამ მონაცემის გამოსახვა კი უნდა მოხდეს html დოკუმენტიდან jinjaს ენის საშუალებით
def product_list(request):
    all_product = Product.objects.all().select_related('categories')
    total_products = all_product.count()
    return render(request, "products.html", {'products' : all_product})
# <!--  იმისათვის რომ ბექიდან წამოღებული მონაცემი გამოვსახოთ ვიყენებთ ჯინჯას ენას, context ით გამოტანებული ცვლადის გამოსახვა შეგვიძლია {{ context_name }} ით,
# მაგრამ გამოიტანს query_setს დიქტის სახით, იმისათვის რომ დალაგებული და ვიზუალურად გარჩევადი იყოს შეგვიძლია გადავიაროთ for ციკლით და სათითაოდ გამოვიტანოთ ისინი  -->
# <!-- for ციკლიცთვის ან if ბლოკისათვის ვიყენებთ {% %} ფიგურული ფრჩხილები და პროცენტის ნიშანი შიგნით, ხოლო ცვლადის გამოსატანად კი უშუალოდ {{}} ორი ფიგურული ფრჩხილები  -->
# შეგვიძლია forიდან ამოღებულ მონაცემების ატრიბუტებიც გამოვიტანოთ მხოლოდ









# იმისათვის რომ კონკრეტული პროდუქტისნ მთლიანი მონაცემი გამოვიტანოთ ამისათვისაც უნდა შევქმნათ ახალი გვერდი, სადაც უშუალოდ ერთი პროდუქტის მთლიან მონაცემს გამოიტანს
# ყოველ პროდუქტს სათთაოდ არ შევუქმნათ ახალი გვერდი, უმჯობესია რომ ერთი გვერდი შევქმნათ სადაც იმ პროდუქტის მონაცემს გამოიტანს რომელიც მომხმარებელს სურს
# ამისათვის ჯერ კონკრეტული პროდუქტზე უნდა განვახორციელოთ წვდომა, რისთვისაც ვიყენებთ pk ან id,
# მონაცემის id უნდა დავიჭიროთ რომელი პროდუქტის აიდისაც დავიჭერთ იმ პროდიქტის მონაცემებს გამოიტანს ამ გვერდზე
# ფუქნციას requestთან ერთად, მეორე პარამეტრიც უნდა გადავცეთ idის სახით, რასაც ძირითადად ვარქმევთ product_pk,
# ამ გვერდის ენდფოინთთან ერთად რომელი პროდუქტის აიდიც წამოვა იმ პროდიუქტის მონაცემებს გამოვიტანთ

# product ისგან განსხვავებით აქ უნდა გავფილტროთ და მონაცემი ამოვიღოთ id ით და ეს id უნდა გავუტოლოთ ჩვენს მიერ გადაცემულ პარამეტრს,
# რათა ეს წამოღებული id დაიჭიროს პარამეტრმა და ამ idის მონაცემი გამოვიტანოთ
def add_product(request):
    if request.method == "POST":
        form = ProductForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect("store:product_list")
    else:
        form = ProductForm()
    return render(request, "add_product.html", {'form' : form})


def product_details(request, product_pk):
    product = get_object_or_404(Product, id=product_pk)
    return render(request, "product_details.html", {'product' : product})
# მას შემდეგ რაც ფუქნციას ავაწყობთ, უნდა შევქმნათ url >>> url.py ფეიჯი



# get_object_404 ვიყენებთ იმისათვის რომ პროდუქტის არ ქონის შემთხვევაში ერორზე არ გავიდეს საიტი და მომხმარებელს გამოუტანოს რომ პროდუქტი არ არსებობს
# ამისათვის მონაცემის ბაზიდან წამოღებისას get_object_404 უნდა გადავცეთ:
# 1: რა კლასიც გვინდა, ამ შემთხვევაში product რომელიც მოგვაქვს ბაზიდან და
# 2: მეორე პარამეტრად უნდა გადავცეთ id გავიტოლოთ მეორე პარამეტრს






# იმისათვის რომ თითოეული პროდუქტის მონაცემი დავაკავშიროთ საიტს, ისევ jinjaს ენას ვიყენებთ, მაგრამ urlში nameსთან ერთად უნდა გადავცეთ პარამეტრი რომ ონაცემის id იყოს შენი აიდი
# {% url 'store:product_details' product.id %}
# რადგანაც ამ ფუნქციას მეორე პარამეტრიც სწირდება id ის სახით, უნდა გავუწეროთ რომ nameთან ერთად,
# ფუნქციას მეორე პარამეტრად გადაეცი შემივე აიდი რითიც ფუნქცია გაეშვება
# {% url 'store:product_details' product.id %}
# ამისათვის nameს შემდეგ შეგვიძლია დავუწეროთ ფუნქციის პარამეტრის სახელი გავუტოლოთ product.id ის ან მხოლოდ product.id გავუწეროთ
# ორივე შემთხვევაში იმუშავებს


